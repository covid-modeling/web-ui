import {input} from '@covid-modeling/api'
import Joi from '@hapi/joi'
import Debug from 'debug'
import omit from 'lodash/omit'
import {Region, TopLevelRegion} from '../types/regions'
import {addDays, maxDate, toYYYYMMDD} from './dateFunctions'
import {getDefaultContactReduction} from './default-contact-reduction'
import {newSimulationSchema} from './simulation-schema'
import {InterventionMap} from './simulation-types'

const debug = Debug('app:new-simulation-state')

// To be moved to shared location
type ISODate = string

/**
 * The state object used in the react page
 */
export interface NewSimulationState {
  region: TopLevelRegion
  subregion: Region
  label: string
  r0: number | undefined
  interventionPeriods: InterventionPeriod[]
}

/**
 * The data sent from web UI to backend
 */
export interface NewSimulationConfig {
  regionID: string
  subregionID?: string
  label: string
  r0: number | undefined
  interventionPeriods: input.InterventionPeriod[]
}

export interface StrategyDescription {
  label: string
  intensities?: Record<input.Intensity, string>
}

export const StrategyDescriptions: Record<string, StrategyDescription> = {
  socialDistancing: {
    label: 'Social Distancing',
    intensities: {
      [input.Intensity.Aggressive]:
        'Statewide lockdown (Assumes 90% social contact reduction)',
      [input.Intensity.Moderate]:
        'Stay at Home or state curfew (Assumes 75% social contact reduction)',
      [input.Intensity.Mild]:
        'Restrict any mass gatherings (Assumes 50% social contact reduction)'
    }
  },
  schoolClosure: {label: 'School Closure'},
  caseIsolation: {label: 'Case Isolation'},
  voluntaryHomeQuarantine: {label: 'Voluntary Home Quarantine'}
}

export type StrategyKey =
  | 'socialDistancing'
  | 'schoolClosure'
  | 'caseIsolation'
  | 'voluntaryHomeQuarantine'

export interface InterventionPeriod
  extends Omit<input.InterventionPeriod, 'reductionPopulationContact'> {
  isAutoGenerated: boolean
  // We need to support an empty string for reductionPopulationContact because
  // that is the default value for new periods
  reductionPopulationContact: number | ''
}

/**
 *
 * @param state simulation state from React UI
 *
 * @return simulation config required by the back end.
 */
export function createFormBody(state: NewSimulationState): NewSimulationConfig {
  return {
    regionID: state.region.id,
    subregionID:
      state.subregion.id !== '_self' ? state.subregion.id : undefined,
    label: state.label,
    r0: state.r0,
    interventionPeriods: state.interventionPeriods.map(period => ({
      ...omit(period, 'isAutoGenerated'),

      // note: allow for invalid values since we check for it later
      reductionPopulationContact:
        typeof period.reductionPopulationContact === 'number'
          ? period.reductionPopulationContact
          : ((undefined as unknown) as number)
    }))
  }
}

type Action =
  | {
      type: 'SET_LABEL'
      label: string
    }
  | {
      type: 'SET_R0'
      r0: number | undefined
    }
  | {
      type: 'SET_REGION'
      region: TopLevelRegion
      interventions: InterventionMap
    }
  | {
      type: 'SET_SUBREGION'
      subregion: Region
      interventions: InterventionMap
    }
  | {
      type: 'UPDATE_PERIOD'
      period: InterventionPeriod
      newPeriod: Partial<InterventionPeriod>
    }
  | {
      type: 'UPDATE_PERIOD_INTERVENTIONS'
      period: InterventionPeriod
      update: Pick<InterventionPeriod, StrategyKey>
    }
  | {
      type: 'ADD_PERIOD'
      period: InterventionPeriod
    }
  | {
      type: 'REMOVE_PERIOD'
      period: InterventionPeriod
    }

export function initializeSimulationState(
  initialState: Pick<NewSimulationState, 'region' | 'subregion'>,
  interventions: InterventionMap
): NewSimulationState {
  return {
    ...initialState,
    r0: undefined,
    label: `Simulation created on ${toYYYYMMDD()}`,
    interventionPeriods: autoFillParameters(
      initialState.region,
      initialState.subregion,
      interventions
    )
  }
}

export function reducer(
  state: NewSimulationState,
  action: Action
): NewSimulationState {
  debug('reducer state=%O action=%o', state, action)

  switch (action.type) {
    case 'SET_LABEL':
      return {...state, label: action.label}

    case 'SET_R0':
      return {...state, r0: action.r0}

    case 'SET_REGION':
      return {
        ...state,
        region: action.region,
        subregion: Object.values(action.region.regions)[0],
        interventionPeriods: autoFillParameters(
          action.region,
          Object.values(action.region.regions)[0],
          action.interventions
        )
      }

    case 'SET_SUBREGION':
      return {
        ...state,
        subregion: action.subregion,
        interventionPeriods: autoFillParameters(
          state.region,
          action.subregion,
          action.interventions
        )
      }

    case 'ADD_PERIOD': {
      const newPeriod: InterventionPeriod = {
        ...action.period,
        reductionPopulationContact:
          getDefaultContactReduction(action.period) ?? ''
      }
      const periods = [...state.interventionPeriods, newPeriod]
      return {
        ...state,
        interventionPeriods: periods
      }
    }
    case 'REMOVE_PERIOD': {
      const periods = state.interventionPeriods.filter(
        period => period !== action.period
      )
      return {
        ...state,
        interventionPeriods: periods
      }
    }
    case 'UPDATE_PERIOD': {
      const periods = [...state.interventionPeriods]
      const index = periods.findIndex(period => period === action.period)
      const newPeriod = {
        ...action.period,
        ...action.newPeriod,
        isAutoGenerated: false
      }
      periods[index] = newPeriod
      return {
        ...state,
        interventionPeriods: periods
      }
    }
    case 'UPDATE_PERIOD_INTERVENTIONS': {
      const periods = [...state.interventionPeriods]
      const index = periods.findIndex(period => period === action.period)
      const newPeriod = {
        ...action.period,
        ...action.update,
        isAutoGenerated: false
      }

      const newReduction = getDefaultContactReduction(newPeriod)
      newPeriod.reductionPopulationContact = newReduction ?? ''

      periods[index] = {...newPeriod}
      return {
        ...state,
        interventionPeriods: periods
      }
    }
  }
}

function autoFillParameters(
  region: Region,
  subregion: Region | undefined,
  interventions: InterventionMap
): InterventionPeriod[] {
  if (!subregion || region.id !== 'US') {
    return []
  }
  const regionInterventions = interventions[region.id][subregion.id]
  if (!regionInterventions) {
    return []
  }

  const rawInterventions = [] as {
    type: StrategyKey
    startDate: input.ISODate
    intensity: input.Intensity
  }[]

  function addIntervention(
    name: string,
    type: StrategyKey,
    intensity: input.Intensity
  ) {
    const namedInterventions = regionInterventions[name]
    if (namedInterventions?.dateEnacted) {
      rawInterventions.push({
        type,
        intensity,
        startDate: namedInterventions.dateEnacted
      })
    }
  }
  addIntervention('SchoolClose', 'schoolClosure', input.Intensity.Aggressive)
  addIntervention('GathRestrict10', 'socialDistancing', input.Intensity.Mild)
  addIntervention('StayAtHome', 'socialDistancing', input.Intensity.Moderate)
  addIntervention('StateCurfew', 'socialDistancing', input.Intensity.Moderate)

  // Sort by start date and create initial interventions set
  let interventionPeriods: InterventionPeriod[] = rawInterventions
    .sort((i1, i2) => i1.startDate.localeCompare(i2.startDate))
    .map(raw => ({
      startDate: raw.startDate,
      reductionPopulationContact: '',
      isAutoGenerated: true,
      voluntaryHomeQuarantine: input.Intensity.Aggressive,
      caseIsolation: input.Intensity.Aggressive,
      [raw.type]: raw.intensity
    }))

  // merge with previous item and dedup
  interventionPeriods = interventionPeriods
    .reduce((combined, interventionPeriod, i) => {
      combined.push({
        ...(combined[i - 1] || {}),
        ...interventionPeriod
      })
      return combined
    }, [] as InterventionPeriod[])
    .filter((current, i, array) => {
      // Remove a period if the next one shares a start date
      // This happens when multiple interventions are announced on
      // the same day.
      const next = array[i + 1]
      return !next || next.startDate !== current.startDate
    })

    .filter((current, i, array) => {
      // Only show the current period if it is different from previous one
      // This happens when interventions change, but not in a way that is
      // relevant to our heuristics.
      const previous = array[i - 1]
      return (
        !previous ||
        previous.socialDistancing !== current.socialDistancing ||
        previous.schoolClosure !== current.schoolClosure
      )
    })

  // Apply default reduction in contact.
  interventionPeriods = interventionPeriods.map(period => {
    const reductionPopulationContact = getDefaultContactReduction(period)

    if (reductionPopulationContact != null) {
      return {...period, reductionPopulationContact}
    } else {
      return period
    }
  })

  return interventionPeriods
}

export function validateSchema(
  config: NewSimulationConfig
): Joi.ValidationError | undefined {
  const {error} = newSimulationSchema.validate(config, {
    abortEarly: false,
    // eslint-disable-next-line
    // @ts-ignore
    errors: {wrap: {label: ''}}, // (Joi TS types are wrong)
    messages: {
      'interventions.strategyRequired':
        'Interventions must contain at least one active strategy across all periods',
      'interventions.chronology':
        "Start date must be after the previous period's start date",
      'reductionPopulationContact.bounds':
        'Estimated population contact reduction must be between 0% and 100%'
    }
  })

  return error
}

/**
 * Finds the start date of the next intervention period to add.
 *
 * The heuristic is that we choose the current date if the last intervention
 * period is before the current date. Otherwise, we use the day after the
 * last intervention date.
 *
 * @param interventionPeriods Current list of interventions
 */
export function getNextInterventionPeriodStart(
  interventionPeriods: InterventionPeriod[]
): ISODate {
  const today = toYYYYMMDD()
  if (!interventionPeriods.length) {
    return today
  }
  const dayAfterLastStartDate = addDays(
    interventionPeriods[interventionPeriods.length - 1].startDate,
    1
  )
  return maxDate(today, dayAfterLastStartDate)
}

/**
 * Finds a heuristically reasonable end to all interventions. The heuristic is to
 * take 90 days after the start date of the last intervention or today (whichever is greater).
 *
 * @param interventionPeriods Current list of interventions
 */
export function getInterventionsEnd(
  interventionPeriods: InterventionPeriod[]
): ISODate {
  const threeMonthsLater = addDays(toYYYYMMDD(), 90)
  if (!interventionPeriods.length) {
    return threeMonthsLater
  }
  const threeMonthsAfterLastStartDate = addDays(
    interventionPeriods[interventionPeriods.length - 1].startDate,
    90
  )
  return maxDate(threeMonthsLater, threeMonthsAfterLastStartDate)
}
